{
  "posts": [
    {
      "id": "616198d8ce9a7f4c78ab79bc",
      "uuid": "8fe624bc-6fbf-4341-adc3-61ec2070d721",
      "title": "Let's build Vue directives: Adding a wave effect to buttons",
      "slug": "lets-build-vue-directives-adding-a-wave-effect-to-buttons",
      "html": "<blockquote>TL: DR - take me to the code<br><br>1. <a href=\"https://codesandbox.io/s/v-ripple-vue-2-wonkg\">Vue 2 Code Sandbox</a><br>2. <a href=\"https://codesandbox.io/s/v-ripple-vue-3-joji0\">Vue 3 Code Sandbox</a><br>3. <a href=\"https://v3.vuejs.org/guide/migration/custom-directives.html#overview.\">Difference between Vue 2 and Vue 3 implementation</a> </blockquote><p>Material design was built around the idea of creating clean user interfaces with rich user feedback. One part of its toolkit is the '<a href=\"https://material.io/develop/ios/supporting/ripple\">Ripple Component</a>'. Whenever an element that uses 'Ripple' is clicked, it emits waves outwards from the mouse pointer. This signals a user that the click, or touch respectively, was recognized. </p><p>Using it in your Vue.js web application provides you this simple, yet elegant way of responding to user interactions.</p><h2 id=\"reasons-for-a-vue-directive\">Reasons for a Vue directive</h2><p>There are several excellent guides on the internet on how to achieve the same functionality with vanilla Javascript. There are also pure CSS implementations. Bear with me though, a custom Vue directive is still a valid choice, because it: </p><ul><li>is easier to reuse - all styling and animation happens inside the directive's code</li><li>requires no selectors but uses Vue's built-in low-level DOM access</li><li>can be directly attached to any element with <code>v-ripple</code></li></ul><blockquote>Please note that this is not an exact replica of the Mateiral Design implementation style. You can, however, tweak the directive's functionality according to your needs</blockquote><h2 id=\"setup-a-vue-3-project-with-vite\">Setup a Vue 3 Project with Vite</h2><p>We'll use <a href=\"https://vitejs.dev/guide/\">Vite</a> to spin up a basic application. You can alternatively use <a href=\"https://cli.vuejs.org/guide/\">Vue CLI</a>. </p><p>Change into a directory of your choice and type: </p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\"># 1: Init your project\nnpm init vite@latest # using Vite with npm\n# yarn create vite   # using Vite with yarn\n# vue create .       # using Vue CLI\n\n# 2: Change into the created folder and start the dev server\ncd vite-project\nnpm install\nnpm run dev\n</code></pre>\n<!--kg-card-end: markdown--><h2 id=\"make-the-app-object-available-for-directive-registration\">Make the app object available for directive registration</h2><p>Before registering our custom directives, let's make a small adjustment in Vue's main file. It uses <code>createApp</code> on the fly, but we need the created app object to register components on. </p><blockquote>This step is optional, you could also chain <code>.directive()</code> as part of the createApp bootstrapping process.</blockquote><!--kg-card-begin: markdown--><pre><code class=\"language-js\">// Inside main.js: Change this \nimport { createApp } from 'vue'\nimport App from './App.vue'\n\ncreateApp(App).mount('#app')\n\n// ------\n\n// to \nimport { createApp } from 'vue'\nimport App from './App.vue'\n\nconst app = createApp(App)\n\n// ... register directives here\n\napp.mount('#app')\n</code></pre>\n<!--kg-card-end: markdown--><p>With <code>app.directive(directiveName, directiveFunction)</code>, we're now able to register our own directives everywhere in the app.</p><h2 id=\"create-the-ripple-directive\">Create the ripple directive</h2><p>The functionality we are about to achieve breaks down into three significant components: </p><ul><li>A parent function is responsible to create a DOM helper element and handling the following two commands</li><li>One nested function applies styles to the helper element</li><li>A second nested function creates the ripple animation layout</li></ul><p>We can then use the standard Vue 3 <code>mounted</code> lifecycle to apply the directive. Let's start by creating a <code>/directives</code> folder in the <code>/src</code> of our project and name it <code>vRipple.js</code>. </p><h3 id=\"the-parent-function\">The parent function</h3><p>In this file, add the following code</p><!--kg-card-begin: markdown--><pre><code class=\"language-js\">const handleRipple = (element, binding, ev) =&gt; {\n  const rippleElement = document.createElement(&quot;span&quot;);\n  let currentDiameter = 1;\n  let currentOpacity = 0.65;\n  let animationHandler = setInterval(animateRippleSpread, 15);\n  applyRippleStyle();\n\n  /* function applyRippleStyle() {...} */\n\n  /* function animateRippleSpread() {...} */\n};\n\n// Hook the directive to the DOM element\nconst vRipple = {\n  mounted: (el, binding) =&gt; {\n    el.style.position = &quot;relative&quot;;\n    el.style.overflow = &quot;hidden&quot;;\n    el.addEventListener(&quot;click&quot;, (ev) =&gt; handleRipple(el, binding, ev));\n  }\n};\n\nexport default vRipple;\n</code></pre>\n<!--kg-card-end: markdown--><p>We will use <code>currentDiameter</code> and <code>currentOpacity</code> for the wave effect. An interval handler will come in handy to halt the animation once its spread reaches the outer limits.</p><h3 id=\"apply-the-basic-ripple-effect-style\">Apply the basic ripple effect style</h3><p>The first child function needs to be called once the <code>span</code> helper element is created. It calculates where on the button the click took place and handles positioning and basic styles accordingly. You can change these to match your own taste or even extend them.</p><!--kg-card-begin: markdown--><pre><code class=\"language-js\">function applyRippleStyle() {\n  const elementCoordinates = element.getBoundingClientRect();\n  const offsetY = ev.clientY - elementCoordinates.y;\n  const offsetX = ev.clientX - elementCoordinates.x;\n\n  rippleElement.style.position = &quot;absolute&quot;;\n  rippleElement.style.height = &quot;5px&quot;;\n  rippleElement.style.width = &quot;5px&quot;;\n  rippleElement.style.borderRadius = &quot;100%&quot;;\n  rippleElement.style.backgroundColor = &quot;#f2f2f2&quot;;\n  rippleElement.style.left = `${offsetX}px`;\n  rippleElement.style.top = `${offsetY}px`;\n  ev.target.appendChild(rippleElement);\n}\n</code></pre>\n<!--kg-card-end: markdown--><h3 id=\"create-the-ripple-animation\">Create the ripple animation</h3><p>Inside <code>animateRippleSpread</code>, we're letting the actual magic happen. This function is called every 15 milliseconds. It conditionally alters the size and opacity of the <code>span</code> helper <strong>or</strong> removes the element once its maximum diameter is reached.</p><!--kg-card-begin: markdown--><pre><code class=\"language-js\">function animateRippleSpread() {\n  const maximalDiameter = +binding.value || 50;\n  if (currentDiameter &lt;= maximalDiameter) {\n    currentDiameter++;\n    currentOpacity -= 0.65 / maximalDiameter;\n    rippleElement.style.transform = `scale(${currentDiameter})`;\n    rippleElement.style.opacity = `${currentOpacity}`;\n  } else {\n    rippleElement.remove();\n    clearInterval(animationHandler);\n  }\n}\n</code></pre>\n<!--kg-card-end: markdown--><blockquote>Note that when you bind a value to the directive, the animation's duration will increase with the maximum size of the ripple element. This will result in a longer and larger wave.</blockquote><p>We're almost done. The one thing left to do is to register the directive and try it out: </p><p>Inside the <code>main.js</code> file, register the directive as follows: </p><!--kg-card-begin: markdown--><pre><code class=\"language-js\">import { createApp } from 'vue'\nimport App from './App.vue'\nimport vRipple from './directives/vRipple'\n\nconst app = createApp(App)\n\napp.directive('ripple', vRipple)\n\napp.mount('#app')\n</code></pre>\n<!--kg-card-end: markdown--><h2 id=\"use-the-directive-on-the-template\">Use the directive on the template</h2><p>All left to do is to apply <code>v-ripple</code> to an element of your choice. You can either try this out in your own environment or interactively using the Code Sandboxes for Vue2 or <a href=\"https://codesandbox.io/s/v-ripple-vue-3-joji0?file=/src/App.vue\">Vue3</a>.</p><p>And there we have it. A fully functional ripple directive that provides rich user feedback upon clicking an element. </p>",
      "comment_id": "616198d8ce9a7f4c78ab79bc",
      "feature_image": null,
      "featured": false,
      "created_at": "2021-10-09T15:27:52.000+02:00",
      "updated_at": "2021-12-10T16:19:54.000+01:00",
      "published_at": "2021-12-10T10:00:00.000+01:00",
      "custom_excerpt": "The wave, aka the ripple effect, became popular with Google's material design guidelines. When a user interacts with a button, a wave-like animation would spread outwards from the clicking/touching point. Read on to learn how to implement this feature with a Vue.js directive.",
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "custom_template": null,
      "canonical_url": null,
      "primary_author": null,
      "primary_tag": null,
      "url": "https://blog.q-bit.me/lets-build-vue-directives-adding-a-wave-effect-to-buttons/",
      "excerpt": "The wave, aka the ripple effect, became popular with Google's material design guidelines. When a user interacts with a button, a wave-like animation would spread outwards from the clicking/touching point. Read on to learn how to implement this feature with a Vue.js directive.",
      "page": false,
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "frontmatter": null
    },
    {
      "id": "60fd811b2dcbe203bf99245f",
      "uuid": "ad93850b-9d4f-41e2-97b1-7827525f1859",
      "title": "A step-by-step guide to developing and deploying Vue apps with docker, part two",
      "slug": "a-step-by-step-guide-for-developing-and-deploying-a-vue-js-app-with-docker-part-two",
      "html": "<blockquote>Haven't read the previous article yet? <br>- Check out the <a href=\"https://blog.q-bit.me/how-to-develop-and-deploy-a-vue-js-app-with-docker-part-one/\">first part of the Vue-Docker series here</a>.<br>- Or if you're <a href=\"https://github.com/tq-bit/vue-docker-development\">TL: DR - take me to the code</a>.</blockquote><h2 id=\"build-the-devcontainer\">Build the dev - container</h2><p>Now that we have Docker installed and scaffolded our project, we can start developing. Let's begin by adding the following to the <code>Dev.Dockerfile</code>: </p><!--kg-card-begin: markdown--><pre><code class=\"language-Dockerfile\">FROM node:14-alpine\n\nWORKDIR /vue_app\n\nEXPOSE 8080\n\nCMD [ &quot;npm&quot;, &quot;run&quot;, &quot;serve&quot; ]\n</code></pre>\n<!--kg-card-end: markdown--><blockquote>In case you wonder about the absence the  <code>npm install</code> command: We'll use the <code>vue_helper</code> container image <a href=\"https://blog.q-bit.me/how-to-develop-and-deploy-a-vue-js-app-with-docker-part-one/#setting-up-the-project\">from the first article</a> to manage npm packages.</blockquote><p>We can build the development container by running: </p><!--kg-card-begin: markdown--><pre><code class=\"language-bash\">docker build  \\\n    -f ./dockerfiles/Dev.Dockerfile \\\n    -t vue_app:dev \n    vue_app\n</code></pre>\n<!--kg-card-end: markdown--><p>You should then receive a container named <code>vue_app</code>. With it, we can start development.</p><p><strong>Note:</strong> Given you have read the previous article, you'll notice a slight difference in the build commands. Previously, we've used <a href=\"https://docs.docker.com/engine/reference/commandline/build/#build-with--\">the STDIN method</a> to read the content of the dockerfile. While it's generally a bit faster, it specifies no <strong>build context</strong> to the Docker daemon. If you try and replicate the STDIN way to build the development app's container, you will run into an error:</p><!--kg-card-begin: markdown--><pre><code class=\"language-bash\">COPY failed: forbidden path outside the build context: ../vue_app/package.json\n</code></pre>\n<!--kg-card-end: markdown--><p>The difference, in a nutshell, is that: </p><ul><li>the STDIN method uses the context of the Dockerfile ( Path: ./dockerfiles/ )</li><li>while the <code>-f</code> - method uses the context of the currently active directory ( Path: ./ )</li></ul><h2 id=\"develop-with-docker\">Develop with Docker</h2><p>To develop, we must keep the container's content synchronized with our local source code. This can easily be achieved by using a bind mount. </p><p>Let's launch the development container by executing the following command: </p><!--kg-card-begin: markdown--><pre><code class=\"language-bash\">docker run \\\n    -v /path/to/project/vue_app:/vue_app \\\n    -p 8080:8080\n    -it vue_app:dev\n</code></pre>\n<!--kg-card-end: markdown--><p>It will:</p><ul><li>run a container based on the tagged image <code>vue_app:dev</code> and expose it on port 8080</li><li>sync the local working directory <code>/path/to/project/vue_app</code> with the container's working directory <code>vue_app</code> over a bind mount</li><li>Open an interactive session so you can keep track of your development server</li></ul><blockquote>If you are trying to get the container up with <a href=\"https://vitejs.dev/\">Vite</a> instead of the Vue CLI,  you must currently (30.10.2021) pass a <code>--host</code> flag in your <code>package.json</code> file:</blockquote><!--kg-card-begin: markdown--><pre><code class=\"language-js\">{ \n  &quot;scripts&quot;: { \n    // ... other scripts  \n    &quot;serve&quot;: &quot;vite --host 0.0.0.0&quot; \n  }\n}\n</code></pre>\n<!--kg-card-end: markdown--><p>When the container is running, the app can be accessed over a browser. Open a new tab at <code>http://localhost:8080</code> and you will see the familiar Vue boilerplate. And thanks to the bind mount, modifications to the code on your local machine will be replicated straight into the container. Vue CLI will pick these up and reload the browser page. </p><p>Finally, try and change the <code>msg</code> property of the <code>HelloWorld</code> component. If the change is visible inside your browser - congratulations - you've successfully set up your own Docker dev-environment 🌟.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://blog.q-bit.me/content/images/2021/10/image-2.png\" class=\"kg-image\" alt loading=\"lazy\" width=\"612\" height=\"410\" srcset=\"https://blog.q-bit.me/content/images/size/w600/2021/10/image-2.png 600w, https://blog.q-bit.me/content/images/2021/10/image-2.png 612w\"></figure><p>You can now change the application to your heart's desire. </p><blockquote>In the <a href=\"https://github.com/tq-bit/vue-docker-development\">repository for this article</a>, I've created a simple to-do-list application that we can deploy later. </blockquote><h2 id=\"prepare-the-app-for-deployment\">Prepare the app for deployment</h2><p>We can already create &amp; manage an app, as well as develop its source code using Docker. What's left to do is to make it ready for a productive environment - without the dev-server overhead. </p><p>There are several ways to do so. You could use the example from the <a href=\"https://blog.q-bit.me/quick-dirty-how-to-deploy-a-fullstack-vue-js-app-with-a-working-node-js-backend/\">Quick &amp; Dirty article I wrote earlier</a>, that is, a custom Express.js server. But why reinvent the wheel if there's a container to the rescue?</p><blockquote>The example you find below is inspired by <a href=\"https://vuejs.org/v2/cookbook/dockerize-vuejs-app.html\">the official Vue 2 Docs</a>. It works equally well with any other kind of JS framework that use Webpack or Vite. </blockquote><p>Let's fill the remaining <code>Deploy.Dockerfile</code> with life by adding these commands:</p><!--kg-card-begin: markdown--><pre><code class=\"language-dockerfile\"># build stage\nFROM node:14-alpine AS build-stage\n\nWORKDIR /vue_app\n\nCOPY package.json ./\n\nRUN npm install\n\nCOPY . .\n\nRUN npm run build\n\n# production stage\nFROM nginx AS production-stage\n\nCOPY --from=build-stage /vue_app/dist /usr/share/nginx/html\n\nEXPOSE 80\n\nCMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]\n</code></pre>\n<!--kg-card-end: markdown--><p>Docker can interpret these to declare two distinct stages. This procedure is commonly referred to as '<a href=\"https://docs.docker.com/develop/develop-images/multistage-build/#name-your-build-stages\">Multi-Stage Building</a>'. </p><ul><li>The build-stage will build the app using the Node.js image</li><li>The production stage will use an <a href=\"https://nginx.org/en/\">Nginx</a> web server image. </li><li>It launches a container that serves the built Vue SPA on port 80</li></ul><p>Stages refer to one another by using the <code>--from</code> - flag. Like this, you can streamline your development workflow. You could, for instance, extend the above commands by adding one or several test phases.</p><blockquote>At this point, you can also configure Nginx as per your project's requirements. Check out the <a href=\"https://hub.docker.com/_/nginx/\">official docs on Dockerhub</a> for more information.</blockquote><p>Once you're ready to ship your app, run: </p><!--kg-card-begin: markdown--><pre><code class=\"language-bash\">docker build \\\n    -f ./dockerfiles/Deploy.Dockerfile \\\n    -t vue_app:production \\\n    vue_app\n</code></pre>\n<!--kg-card-end: markdown--><p>You will receive an image that includes an optimized version of your app. It can be launched anywhere Docker is installed:</p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\">docker run -p 80:80 vue_app:production\n</code></pre>\n<!--kg-card-end: markdown--><p>The application will then be available under <code>http://localhost</code>.</p><p>Let's recap: </p><ul><li>We've filled the two Dockerfiles for development and deployment with commands</li><li>Both provide us a unique way to develop and distribute our app</li><li>Docker also allows us to streamline our deployment process</li><li>This procedure is called 'Multi-Stage Building'</li></ul><h2 id=\"example-github-repos\">Example Github Repos</h2><p>I've collected all the code from the first two articles together in a Github Repos. You are welcome to use it either as a boilerplate or Proof of Concept.</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://github.com/tq-bit/vue-docker-development\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">GitHub - tq-bit/vue-docker-development: A boilerplate repos with three essential Dockerfiles to streamline you Vue app development project.</div><div class=\"kg-bookmark-description\">A boilerplate repos with three essential Dockerfiles to streamline you Vue app development project. - GitHub - tq-bit/vue-docker-development: A boilerplate repos with three essential Dockerfiles to...</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://github.com/fluidicon.png\" alt=\"\"><span class=\"kg-bookmark-author\">GitHub</span><span class=\"kg-bookmark-publisher\">tq-bit</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://opengraph.githubassets.com/2303890d85435f72345b8b4a082724eef34d779b1f8996e09bfd22ebc8e846df/tq-bit/vue-docker-development\" alt=\"\"></div></a></figure><h2 id=\"next-steps\">Next steps</h2><p>While you could use the example as-is, there's still room for improvement. So in the next and final article of the series:</p><ul><li>We'll use Dockerhub to publish our app image</li><li>We'll create a Virtual Host on Digital Ocean and deploy our app to it</li><li>Instead of running each docker command separately, we'll explore the usage of <code>docker-compose</code> for development and deployment</li></ul>",
      "comment_id": "60fd811b2dcbe203bf99245f",
      "feature_image": null,
      "featured": true,
      "created_at": "2021-07-25T17:19:55.000+02:00",
      "updated_at": "2021-11-15T07:53:24.000+01:00",
      "published_at": "2021-11-15T07:50:00.000+01:00",
      "custom_excerpt": "Vue is a great framework to develop user interfaces. It has experienced a great deal of growth in popularity since its initial release in 2014 and still continues to improve. This second part of the series will explain how to develop \"in\" a container and ship your app with a custom Docker workflow",
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "custom_template": null,
      "canonical_url": null,
      "primary_author": null,
      "primary_tag": null,
      "url": "https://blog.q-bit.me/a-step-by-step-guide-for-developing-and-deploying-a-vue-js-app-with-docker-part-two/",
      "excerpt": "Vue is a great framework to develop user interfaces. It has experienced a great deal of growth in popularity since its initial release in 2014 and still continues to improve. This second part of the series will explain how to develop \"in\" a container and ship your app with a custom Docker workflow",
      "page": false,
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "frontmatter": null
    },
    {
      "id": "616c2a23ce9a7f4c78ab7b88",
      "uuid": "641118c1-a7ef-47c6-bed1-b6d7fa01ab4e",
      "title": "Quick & Dirty: How to add a client search feature to your Ghost blog",
      "slug": "how-to-add-a-search-feature-to-your-ghost-cms-blog",
      "html": "<blockquote>Note: This article assumes that you have a basic idea about Ghost theme development. If you need a refresher, <a href=\"https://ghost.org/docs/themes/\">check out the official docs</a> before reading ahead.</blockquote><p>TL: DR - Take me to the code.</p><ul><li><a href=\"https://github.com/tq-bit/candidus-lite/blob/master/partials/search.hbs\">The related partial</a></li><li><a href=\"https://github.com/tq-bit/candidus-lite/blob/master/assets/js/lib/search.js\">The wrapper function</a></li><li><a href=\"https://github.com/tq-bit/candidus-lite/blob/master/assets/js/index.js\">The plugin registration</a> (starting @ line 18)</li><li><a href=\"https://github.com/tq-bit/candidus-lite/blob/master/gulpfile.js\">The gulp task to build the web worker</a> (starting @ line 96)</li></ul><p>The content of these files might change in the future, but the logic will remain the same.</p><h2 id=\"considerations-for-development\">Considerations for development</h2><p>I created this feature with the following questions in mind:</p><ul><li>Where do I get the post data from? -&gt; <a href=\"https://ghost.org/docs/content-api/\">Ghost's Content API</a></li><li>Do I want to execute an HTTP request every time I make a search? -&gt; No</li><li>How do I store relevant information in the client? -&gt; I'll use a <a href=\"https://en.wikipedia.org/wiki/Search_engine_indexing\">clientside index</a></li><li>How do I create and search through an index? -&gt; With the fantastic library <a href=\"https://lunrjs.com/\">Lunr.js</a></li><li>Building an index takes time. How do I reduce stress on the main thread? -&gt; By using a dedicated <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Worker\">Web Worker</a> to build the index every X hours</li></ul><p>Naturally, you could do the same thing on the server-side. I'm happy with how the result turned out though. So let's dive in.</p><h2 id=\"build-the-partial\">Build the partial</h2><blockquote>Link to Github: <a href=\"https://github.com/tq-bit/candidus-lite/blob/master/partials/search.hbs\">The related partial</a></blockquote><p>The result looks like this.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://blog.q-bit.me/content/images/2021/10/image.png\" class=\"kg-image\" alt loading=\"lazy\"></figure><p>It will render all the results from my local index whenever a search is made by the user.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://blog.q-bit.me/content/images/2021/10/image-1.png\" class=\"kg-image\" alt loading=\"lazy\" width=\"885\" height=\"442\" srcset=\"https://blog.q-bit.me/content/images/size/w600/2021/10/image-1.png 600w, https://blog.q-bit.me/content/images/2021/10/image-1.png 885w\" sizes=\"(min-width: 720px) 720px\"></figure><h2 id=\"register-the-plugin\">Register the plugin</h2><p>To build an index, we need to feed it with data. We'll receive these from Ghost's content API, which requires an API key to be accessible.  So head over to your admin panel and <a href=\"https://ghost.org/integrations/custom-integrations/\">create a new integration</a>. </p><p>Then, <a href=\"https://ghost.org/help/using-the-editor/#using-code-injection\">inject the API key</a>, as well as the domain of your blog. </p><!--kg-card-begin: markdown--><pre><code class=\"language-html\">&lt;script&gt;\nconst Q_GHOST_API_ROOT = 'https://blog.q-bit.me';\nconst Q_GHOST_API_KEY = 'content-api-key';\n&lt;/script&gt;\n</code></pre>\n<!--kg-card-end: markdown--><p>Next, we can use the plugin <code>useLunrSearch</code> and extract the necessary functions: </p><!--kg-card-begin: markdown--><pre><code class=\"language-js\">const { \n initLocalIndex, \n search, \n // ... other methods\n} = useLunrSearch(Q_GHOST_API_ROOT, Q_GHOST_API_KEY);\n</code></pre>\n<!--kg-card-end: markdown--><p>Let's check the next two functions in detail now.</p><h2 id=\"initialize-a-local-index\">Initialize a local index</h2><p>We'll need to take the following three steps: </p><ol><li>Get the data from the API -&gt; Done by function <code><a href=\"https://github.com/tq-bit/candidus-lite/blob/master/assets/js/lib/search.js\">fetchPosts</a></code> (line 123)</li><li>Create an index -&gt; Done by WebWorker's <code><a href=\"https://github.com/tq-bit/candidus-lite/blob/master/assets/js/workers/indexworker.js\">buildIndex</a></code></li><li>Save the index and a timestamp to local storage -&gt; Done by <code><a href=\"https://github.com/tq-bit/candidus-lite/blob/master/assets/js/lib/search.js\">saveIndex</a></code> (line 113)</li></ol><p>Let's take a look at how it's done in detail.</p><h3 id=\"get-the-posts\">Get the posts</h3><p>We've passed the URL, as well as the API - key to the parent function <code>useLunrSearch</code>, so they're both available within the nested function's scope. Since we will fetch the posts only once to build our index, I felt free enough to set the limit to a bigger number. </p><p>In the <a href=\"https://github.com/tq-bit/candidus-lite/blob/master/assets/js/lib/search.js\">search.js</a> file:</p><!--kg-card-begin: markdown--><pre><code class=\"language-js\">const fetchPosts = async (limit = 9999) =&gt; {\n  if (!rootUrl) {\n    console.warn('No rootUrl url specified. Using relative path');\n  }\n  if (!key) {\n    throw new Error('No content api key found: Q_GHOST_API_KEY is undefined');\n  }\n\n  const url = rootUrl + path + '?limit=' + limit + '&amp;key=' + key;\n  const response = await fetch(url);\n  const { meta, posts } = await response.json();\n  return posts;\n};\n</code></pre>\n<!--kg-card-end: markdown--><h3 id=\"build-the-index\">Build the index</h3><p>As creating an index is a memory-intensive task, it makes sense to offload it to a Web Worker. It'll do its thing on a separate thread and delivers the result back when it's ready.</p><blockquote>Make sure lunr.js is available in both, the search.js and the indexworker.js context - both files will be executed in separate contexts of the browser.</blockquote><p>In the <a href=\"https://github.com/tq-bit/candidus-lite/blob/master/assets/js/lib/search.js\"><code>search.js</code></a> - file </p><!--kg-card-begin: markdown--><pre><code class=\"language-js\">// register the worker\nconst indexWorker = new Worker('/assets/built/workers/indexworker.js');\n\n//  get the posts\nconst posts = await fetchPosts();\n\n// send them to the worker\nindexWorker.postMessage(posts);\n\n// receive the index back from the worker\nindexWorker.onmessage = (ev) =&gt; {\n const { data: serializedIndex } = ev;\n const lunrIndex = JSON.parse(serializedIndex);\n const timestamp = saveIndex(lunrIndex);\n return timestamp;\n};\n// ...\n</code></pre>\n<!--kg-card-end: markdown--><p>And then in the <code><a href=\"https://github.com/tq-bit/candidus-lite/blob/master/assets/js/workers/indexworker.js\">indexworker.js</a></code> file: </p><ol><li>We'll create a <code>blueprint</code> variable to hold the serialized title and the URL</li><li>We'll receive this string back when searching for posts - it'll be our reference</li><li>Lunr then creates the index by classifying posts and adding documents to it</li><li>Finally, the index is serialized and returned to the calling function when it's requested</li></ol><!--kg-card-begin: markdown--><pre><code class=\"language-js\">const buildIndex = (posts) =&gt; {\n  const documents = posts.map((post) =&gt; {\n    const blueprint = JSON.stringify({ // 1\n      title: post.title,\n      url: post.url,\n    });\n    return {\n      blueprint,\n      title: post.title,\n      excerpt: post.excerpt,\n      html: post.html,\n    };\n  });\n\n  const lunrIndex = lunr(function () {\n    this.ref('blueprint'); // 2\n    this.field('title');\n    this.field('excerpt');\n    this.field('html');\n    documents.forEach(function (doc) {\n      this.add(doc); // 3\n    }, this);\n  });\n  return lunrIndex;\n};\n\nonmessage = ({ data }) =&gt; {\n  const lunrIndex = buildIndex(data);\n  const serializedIndex = JSON.stringify(lunrIndex); // 4\n  postMessage(serializedIndex);\n};\n</code></pre>\n<!--kg-card-end: markdown--><h3 id=\"store-the-result-in-local-storage-and-retrieve-it\">Store the result in local storage and retrieve it</h3><p>Now that we've got the index, we'll have to store it somewhere. The easiest way to do so turned out to be local storage. And to ensure it is regularly updated, we'll add a timestamp to it when it's saved.</p><p>In the <a href=\"https://github.com/tq-bit/candidus-lite/blob/master/assets/js/lib/search.js\"><code>search.js</code></a> - file </p><!--kg-card-begin: markdown--><pre><code class=\"language-js\">const saveIndex = (lunrIndex) =&gt; {\n  const timestamp = new Date().getTime();\n  const payload = {\n    timestamp,\n    lunrIndex,\n  };\n  localStorage.setItem(localIndexName, JSON.stringify(payload));\n  return timestamp;\n};\n\nconst getIndex = () =&gt; {\n  const payload = JSON.parse(localStorage.getItem(localIndexName));\n  if (payload) {\n    return {\n      timestamp: payload.timestamp,\n      // Load the deserialized index \n      lunrIndex: lunr.Index.load(payload.lunrIndex),\n    };\n  }\n};\n</code></pre>\n<!--kg-card-end: markdown--><h2 id=\"query-the-index-for-blueprints\">Query the index for blueprints</h2><p>And that's it. We can now use <code>getIndex</code> and query for something a user puts in. In my example, I use the <code>blueprints</code> (serialized title &amp; URL) to render a list of items. </p><p>In the <a href=\"https://github.com/tq-bit/candidus-lite/blob/master/assets/js/lib/search.js\"><code>search.js</code></a> - file</p><!--kg-card-begin: markdown--><pre><code class=\"language-js\">const search = (ev) =&gt; {\n  const {\n    target: { value },\n  } = ev;\n  const { lunrIndex } = getIndex();\n  const blueprints = queryIndex(lunrIndex, value);\n  return renderQueryResults(value, blueprints);\n};\n</code></pre>\n<!--kg-card-end: markdown--><p>If you are reading this post on my <a href=\"https://blog.q-bit.me/\">blog.q-bit.me</a>, try and press <code>CTRL</code> + <code>K</code> to see the plugin in action.</p><blockquote>This feature is part of my Ghost theme Candidus-Lite. If the post above helped you, I'd appreciate <a href=\"https://github.com/tq-bit/candidus-lite\">if you starred its repos on Github</a></blockquote>",
      "comment_id": "616c2a23ce9a7f4c78ab7b88",
      "feature_image": null,
      "featured": false,
      "created_at": "2021-10-17T15:50:27.000+02:00",
      "updated_at": "2021-10-30T16:59:04.000+02:00",
      "published_at": "2021-10-17T18:35:40.000+02:00",
      "custom_excerpt": "This article attempts to give you an idea of how to implement a search feature for your own Ghost blog. You'll learn how to create your own index, store it on the clientside and query it for results.  In the related code repository, you can also find an implementation example. ",
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "custom_template": null,
      "canonical_url": null,
      "primary_author": null,
      "primary_tag": null,
      "url": "https://blog.q-bit.me/how-to-add-a-search-feature-to-your-ghost-cms-blog/",
      "excerpt": "This article attempts to give you an idea of how to implement a search feature for your own Ghost blog. You'll learn how to create your own index, store it on the clientside and query it for results.  In the related code repository, you can also find an implementation example. ",
      "page": false,
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "frontmatter": null
    },
    {
      "id": "615985c374359d041d2c44b4",
      "uuid": "002f17c9-2d85-485b-b927-72620a94a402",
      "title": "Let's build Vue directives: Scrolling elements into view",
      "slug": "lets-build-vue-directives-scrolling-elements-into-view",
      "html": "<blockquote>TL: DR - take me to the code<br><br>1. <a href=\"https://codesandbox.io/s/v-scroll-vue-2-9rli3?file=/src/main.js\">Vue 2 Code Sandbox</a><br>2. <a href=\"https://codesandbox.io/s/v-scroll-vue-2-9rli3?file=/src/main.js\">Vue 3 Code Sandbox</a><br>3. <a href=\"https://v3.vuejs.org/guide/migration/custom-directives.html#overview.\">Difference between Vue 2 and Vue 3 implementation</a> </blockquote><p>It is one of those features that slowly but steadily found its way into most of the content-heavy pages, such as blogs or documentations. Scrolling elements into view gives your user an intuitive shortcut to the content they'd like to read about.</p><h2 id=\"reasons-for-a-vue-directive\">Reasons for a Vue directive</h2><p>You might wonder - why would I need Javascript, even more, a Vue directive for this? I can use built-in HTML and CSS properties, such as <code>href=\"#headline\"</code> in combination with <code>scroll: smooth</code>. </p><p>In fact, you can. If you don't mind a few limitations: </p><ul><li>A <code>fixed</code> navbar might be in the way of your heading</li><li>You have to give every heading a fixed id or create it with Javascript</li><li>Globally applied smooth scrolling sometimes leads to some funny side effects when using SPA routers</li></ul><p>You could arguably also use vanilla Javascript. Then again, the nature of Vue directives allows for a quick and reusable implementation.</p><blockquote>Please note that this article focuses on Vue 3, in which custom directives are handled slightly different than in Vue 2. Check out the linked code sandboxes in TL:DR for differences in <code>main.js</code> and the <code>vScroll.js</code> directive file.</blockquote><h2 id=\"setup-a-vue-3-project-with-vite\">Setup a Vue 3 Project with Vite</h2><p>We'll use <a href=\"https://vitejs.dev/guide/\">Vite</a> to spin up a basic application. You can alternatively use <a href=\"https://cli.vuejs.org/guide/\">Vue CLI</a>. </p><p>Change into a directory of your choice and type: </p><!--kg-card-begin: markdown--><pre><code class=\"language-shell\"># 1: Init your project\nnpm init vite@latest # using Vite with npm\n# yarn create vite   # using Vite with yarn\n# vue create .       # using Vue CLI\n\n# 2: Change into the created folder and start the dev server\ncd vite-project\nnpm install\nnpm run dev\n</code></pre>\n<!--kg-card-end: markdown--><h2 id=\"make-the-app-object-available-for-directive-registration\">Make the app object available for directive registration</h2><p>Before registering our custom directives, let's make a small adjustment in Vue's main file. It uses <code>createApp</code> on the fly, but we need the created app object to register components on. </p><blockquote>This step is optional, you could also chain <code>.directive()</code> as part of the createApp bootstrapping process.</blockquote><!--kg-card-begin: markdown--><pre><code class=\"language-js\">// Inside main.js: Change this \nimport { createApp } from 'vue'\nimport App from './App.vue'\n\ncreateApp(App).mount('#app')\n\n// ------\n\n// to \nimport { createApp } from 'vue'\nimport App from './App.vue'\n\nconst app = createApp(App)\n\n// ... register directives here\n\napp.mount('#app')\n</code></pre>\n<!--kg-card-end: markdown--><p>With <code>app.directive(directiveName, directiveFunction)</code>, we're now able to register our own directives everywhere in the app.</p><h2 id=\"create-the-scroll-directive\">Create the scroll directive</h2><p>For this purpose, we require two browser functions, both of which are available in all major browsers.</p><ul><li><code>domElement.getBoundingClientRect()</code> to receive the element's coordinates</li><li><code>window.scroll()</code> to scroll to the calculated part of the window</li></ul><p>What's left for us to do is to:</p><ul><li>calculate the difference between the current window position and the element (1)</li><li>make the window scroll to that calculated position (2)</li></ul><p>So let's move ahead and create a folder in the <code>/src</code> folder named <code>/directives</code>. Inside it, create a file named <code>vScroll.js</code> and paste the following code into it: </p><!--kg-card-begin: markdown--><pre><code class=\"language-js\">const vScroll = {\n  mounted: (el) =&gt; {\n    el.style.cursor = 'pointer';\n    el.addEventListener('click', () =&gt; {\n      const coord = el.getBoundingClientRect().top + window.scrollY; //(1)\n      window.scroll({ top: coord, behavior: 'smooth' });  //(2)\n    });\n  },\n};\n\nexport default vScroll;\n</code></pre>\n<!--kg-card-end: markdown--><p>Now let's go back into the <code>main.js</code> file and register <code>vScroll</code>: </p><!--kg-card-begin: markdown--><pre><code class=\"language-js\">import { createApp } from 'vue'\nimport App from './App.vue'\nimport vScroll from './directives/vScroll'\n\nconst app = createApp(App)\n\napp.directive('scroll', vScroll)\n\napp.mount('#app')\n</code></pre>\n<!--kg-card-end: markdown--><h2 id=\"use-the-directive-on-the-template\">Use the directive on the template</h2><p>Now what's left to do is to check whether the directive works as intended. Let's go ahead and replace the content of the <code>App.vue</code> file with a <a href=\"https://blog.q-bit.me/lorem-ipsum-template/\">Lorem Ipsum template</a>.</p><p>Try adding <code>v-scroll</code> to any of the h2 - tags. Now, when clicking on them, they will be smoothly scrolled to the upper part of the window.</p><!--kg-card-begin: markdown--><pre><code class=\"language-html\">&lt;h2 v-scroll&gt;Cursus mattis&lt;/h2&gt;\n</code></pre>\n<!--kg-card-end: markdown--><h2 id=\"what-about-the-fixed-navbar-problem\">What about the fixed navbar problem?</h2><p>The solution in a nutshell: You can bind values to directives! In this case to add a vertical offset when scrolling to an element. These bindings can be accessed the same way as the element itself, given they are passed as an argument in the directive's lifecycle function. In our case, <code>binding.value</code> will resolve to a number we want to subtract from the scroll-top position. </p><p>In the <code>vScroll.js</code> file:</p><!--kg-card-begin: markdown--><pre><code class=\"language-js\">const vScroll = {\n  mounted: (el, binding) =&gt; {\n    el.style.cursor = 'pointer';\n    el.addEventListener('click', () =&gt; {\n      let coord = 0;\n      coord = binding.value\n        ? el.getBoundingClientRect().top + window.scrollY - binding.value\n        : el.getBoundingClientRect().top + window.scrollY;\n        window.scroll({ top: coord, behavior: 'smooth' });\n    });\n  },\n};\n</code></pre>\n<!--kg-card-end: markdown--><p>In the HTML template: </p><!--kg-card-begin: markdown--><pre><code class=\"language-html\">&lt;h2 v-scroll=&quot;200&quot;&gt;\n  Pharetra magna\n&lt;/h2&gt;\n&lt;p&gt;\n  Congue quisque egestas diam in arcu cursus euismod quis viverra. \n  Pharetra magna ac placerat vestibulum lectus mauris ultrices.....\n&lt;/p&gt;\n</code></pre>\n<!--kg-card-end: markdown--><p>If everything went well, you now have a functional directive you can include in any new or existing project.</p><h2 id=\"theres-more-to-it\">There's more to it</h2><p>As you can see, we achieved this functionality fairly easily. You can move even further and extend the directive. For example, dynamically add an icon before the text or mutate the element's style whenever a user interacts with it. If you'd like to get an even deeper understanding of Vue directives, make sure to take a look into the official docs for Vue 3. </p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://v3.vuejs.org/guide/custom-directive.html\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Custom Directives | Vue.js</div><div class=\"kg-bookmark-description\">Vue.js - The Progressive JavaScript Framework</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://v3.vuejs.org/images/icons/apple-icon-152x152.png\" alt=\"\"><span class=\"kg-bookmark-author\">Vue.js</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://v3.vuejs.org/logo.png\" alt=\"\"></div></a></figure>",
      "comment_id": "615985c374359d041d2c44b4",
      "feature_image": null,
      "featured": false,
      "created_at": "2021-10-03T12:28:19.000+02:00",
      "updated_at": "2021-11-08T18:30:26.000+01:00",
      "published_at": "2021-10-03T17:12:10.000+02:00",
      "custom_excerpt": "Directives are one of Vue's most powerful concepts. They provide direct access to a DOM element over its lifecycle. And you're not restricted to the built-in ones but can also write your own custom directives. ",
      "codeinjection_head": null,
      "codeinjection_foot": null,
      "custom_template": null,
      "canonical_url": null,
      "primary_author": null,
      "primary_tag": null,
      "url": "https://blog.q-bit.me/lets-build-vue-directives-scrolling-elements-into-view/",
      "excerpt": "Directives are one of Vue's most powerful concepts. They provide direct access to a DOM element over its lifecycle. And you're not restricted to the built-in ones but can also write your own custom directives. ",
      "page": false,
      "og_image": null,
      "og_title": null,
      "og_description": null,
      "twitter_image": null,
      "twitter_title": null,
      "twitter_description": null,
      "meta_title": null,
      "meta_description": null,
      "frontmatter": null
    }
}
